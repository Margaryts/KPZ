# Lab1 - Principles of Software Design

## 1. DRY (Don't Repeat Yourself)

Принцип DRY вимагає уникати дублювання коду. Це означає, що якщо один і той самий фрагмент коду повторюється більше одного разу, його слід винести в окрему функцію чи клас. У вашому коді цей принцип реалізовано через методи, які використовуються для відображення інформації про продукти та інвентар. Наприклад, метод Display() в класі Product та метод ShowInventory() в класі Warehouse.
Метод Display() виводить інформацію про продукт (назва, ціна та валюта). Цей метод використовується не тільки в класі Product, а й в класі Warehouse для відображення списку всіх продуктів на складі.

- **File**: [Product.cs](./Product.cs), [Warehouse.cs](./Warehouse.cs)
- **Lines**: [Product.Display()] (./Lab1/Product.cs#23), [Warehouse.ShowInventory() (./Lab1/Warehouse.cs#30)

## 2. KISS (Keep It Simple, Stupid)

Принцип KISS полягає в тому, щоб код був простим і зрозумілим. У вашому коді клас Product містить метод ApplyDiscount(), який реалізує одну конкретну задачу — застосування знижки. Логіка цього методу проста, тому що він просто віднімає кількість центів з ціни та створює новий об'єкт Money для оновленої ціни.

- **File**: [Product.cs](./Product.cs)
- **Lines**: [Product.ApplyDiscount()] (./Lab1/Product.cs#)

## 3. SOLID Principles

### 3.1. S - Single Responsibility Principle

Принцип SRP полягає в тому, щоб кожен клас мав тільки одну відповідальність. У вашому коді кожен клас виконує лише одну чітко визначену задачу:
- Клас Money відповідає за зберігання і виведення інформації про гроші.
- Клас Product управляє даними продукту та його ціною.
- Клас Warehouse відповідає за управління списком продуктів.
- Клас Reporting генерує звіти по інвентарю.

- **Files**: [Money.cs](./Money.cs./Warehouse.cs), [Reporting.cs](./Reporting.cs)

### 3.2. O - Open/Closed Principle

Принцип OCP стверджує, що клас повинен бути відкритий для розширення, але закритий для модифікацій. Наприклад, якщо ви хочете додати нові види знижок для продуктів, ви можете просто додати нові методи в клас Product, не змінюючи існуючий код.

- **File**: [Product.cs](./Product.cs)
- **Lines**: [Product.ApplyDiscount()] (./Lab1/Product.cs#14)

### 3.3. L - Liskov Substitution Principle

Принцип LSP вимагає, щоб об'єкти підкласів могли замінювати об'єкти базового класу без порушення коректності роботи програми. У цьому прикладі, хоча немає явного використання спадкування, ми можемо розглянути можливість розширення програми, створивши підкласи для різних типів продуктів. Це дозволить замінити базовий клас Product на підклас без порушення функціональності.

**Приклад:** Уявімо, що ми додамо клас DiscountedProduct, який успадковуватиме Product і додаватиме додаткову логіку для застосування знижок.

### 3.4. I - Interface Segregation Principle

Принцип ISP стверджує, що клієнти не повинні залежати від інтерфейсів, які вони не використовують. Хоча в цьому коді інтерфейси не застосовуються, у майбутньому можна створити інтерфейси, як, наприклад, IProduct для різних типів продуктів, що дозволить уникнути залежності від непотрібних методів.

**Приклад:** Якщо ми додамо різні типи продуктів (наприклад, DiscountedProduct або BulkProduct), можна буде створити окремі інтерфейси для кожного типу.

### 3.5. D - Dependency Inversion Principle

Принцип DIP вимагає, щоб класи залежали від абстракцій, а не від конкретних реалізацій. Клас Reporting залежить від абстракції Warehouse (в даному випадку це клас), а не від конкретної реалізації складу.

- **File**: [Reporting.cs](./Reporting.cs)
- **Lines**: [Reporting(Warehouse warehouse)] (./Lab/Reporting.cs#6)

## 4. YAGNI (You Aren't Gonna Need It)

Принцип YAGNI стверджує, що не слід додавати функціональність, яку ви не плануєте використовувати. Ви реалізуєте лише базовий функціонал для управління продуктами та їх цінами, без зайвих деталей.

**Приклад:** В коді немає складних алгоритмів для розрахунку податків чи валюти, хоча це можна додати в майбутньому. Це демонструє принцип YAGNI.

## 5. Composition Over Inheritance

Принцип Composition Over Inheritance вимагає використання композиції замість успадкування для досягнення більшої гнучкості. У вашому коді замість використання спадкування ви створюєте класи, які містять інші об'єкти, що демонструє композицію. Наприклад, клас Warehouse містить список об'єктів Product, замість того щоб успадковувати від якогось базового складу.

- **File**: [Warehouse.cs](./Warehouse.cs)
- **Lines**: [private List<Product> products] (./Lab1/Product.cs#7)

## 6. Program to Interfaces, Not Implementations

Принцип Program to Interfaces, Not Implementations заохочує програмувати таким чином, щоб залежності були від інтерфейсів або абстракцій, а не від конкретних реалізацій. Хоча в вашому коді інтерфейси не використовуються, ви все ж таки працюєте з абстракціями, такими як клас Warehouse, що дозволяє в майбутньому реалізувати інтерфейси для різних типів складів.

## 7. Fail Fast

Принцип Fail Fast полягає в тому, щоб програма швидко повідомляла про помилки, замість того щоб продовжувати виконання з неправильними даними. У вашому коді перевірка знижки в методі ApplyDiscount() забезпечує швидке відображення помилок.

**Приклад:** Якщо знижка перевищує суму на рахунку, метод застосує нову ціну, що гарантує правильність даних.




